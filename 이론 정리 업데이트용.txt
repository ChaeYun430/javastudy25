몇개의 열거 상수(enumeration constant) 중에서 하나의 상수를 저장하는 데이터 타입
형식: 열거 타입 이름으로 소스파일(*.java)를 생성, 첫문자를 대문자

바이트 코드 파일 생성
이클립스에서 class를 생성하고 저장을 누르면 바이트코드 파일은 *.class가 bin폴더 아래에 생성
 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.
가급적 소스파일 하나당 동일한 이름의 클래스 하나를 선언하는 것이 좋다.

클래스의 용도
라이브러리(API : Application Program Interface)용: 다른 클래스에서 이용할 목적으로 설계
실행용: main메서드가 있는 클래스(단 하나의 클래스)


객체 생성
new연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 가리키도록 되어 있다.
이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.


클래스에는 객체가 가져야할 구성 맴버가 선언
구성 맴버: 필드(Field), 생성자(Constructor), 메소드(method)
생략되거나 복수 개가 작성 될 수 있다.

필드 
객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지 않는다. (필드:전역 변수, main()의 변수: 지역 변수)
변수(local variable) : 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸 된다.

생성자 
객체 초기화: 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것
생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다.

기본생성자
생략 가능 (객체가 생성될 때 사용되는 메서드: 클래스명과 같은 이름)
객체가 생성되면서 변수에 값이 저장됨
우리가 클래스 내부에 생성자 선언을 생략 했다면 컴파일러는 중괄호 블럭 내용이 비어있는 기본 생성자(Default Constructor)를 바이트 코드에 자동으로 추가한다.
활용: main()에서 객체 생성 후 해당 객체의 메서드에서 변수값을 넣는다.

사용자 지정 생성자
개발자가 응용하는 기법
사용자 지정 생성자가 만들어지면 기본생성자는 자동으로 생성되지 않는다. 
명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서
활용: main()에서 값을 입력 받은 후 객체 생성 시 생성자 호출 후 초기화 시 값을 넣는다.  

생성자 매개변수로 필드명을 사용하면 name이 중복배정되서 원하는 값이 나오지 않는다.
해결법 : this.를 사용해본다. -> this는 객체 자신의 참조인데, 우리가 우리자신을 나라고 하듯이 객체가 객체 자신을 this라고 한다.

생성자 오버로딩 
매개변수 타입, 개수, 순서가 다르게 선언
외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화 될 필요가 있다.
매개 변수의 타입과 개수 그리고 선언된 순서가 똑같은 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.


다른 생성자 호출(this())////모르겠음
필드 초기화 내용은 생성자에만 집중적으로 작성하고 
나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
클래스( [매개변수선언, ... ) { this( 매개변수, .... 값.... ) ; 실행문; } //해당 클래스의 다른 생성자 호출
this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.
this()의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공
this()다음에는 추가적인 실행문이 올수 있다.
호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행

return

매개변수의 수를 모를 때

해결책 : 배열을 활용해보자.
배열의 항목수는 호출할 때 결정
매개 변수를 배열 타입으로 선언하면, 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.

배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다.
sum2() 메소드의 매개변수를 "..."를 선언하게 되면, 메소드 호출시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.
int sum2(int ... values) { } 
int result = sum2(1, 2, 3, 4, 5) ; 
int result = sum2(new int[] { 1, 2, 3, 4, 5} );

return문이 실행되면 메소드는 즉시 종료 된다.
return문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환 될 수 있어야 한다(자동타입변환가능)
void문에서는 return을 사용하면 메소드 실행을 강제 종료시킨다.(break 역할)



