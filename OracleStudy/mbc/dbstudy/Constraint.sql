--=======================<<<제약 조건>>>============================
--개념: 어떤 테이블에 저장할 데이터의 특성을 정의하는 데 사용하는 특수한 규칙
--테이블의 특정 열에 지정
--목적: 데이터의 정확성 유지
--DB 설계 시점, 테이블 생성시 주로 지정, 테이블 생성 후에도 추가, 변경, 삭제 가능

--data integrity: 데이터 베이스에 저장되는 데이터의 정확성과 일관성을 보장한다.
--domain integrity
--열에 저장되는 값의 적정 여부 확인.
--자료형, 적절한 형식의 데이터, NULL 여부같은 종해놓은 범위를 만족하는 데이터임을 규정
--entity integrity
--테이블 데이터를 유일하게 식별할 수 있는 기본키는 반드시 값을 가지고 있어야 하며 NULL 불가, 중복 불가를 규정
--referential integrity
--참조 테이블의 외래키 같은 참조 테이블의 기본키로서 존재해야 하며 NULL이 가능


--NOT NULL(C) : NULL 불가, NULL을 제외한 데이터의 중복 허용
--UNIQUE(U) : 데이터의 중복 불가, NULL은 중복에서 제외
--PRIMARY KEY (P) : 기본키의 조건, 테이블에 하나만 지정 가능
--FOREIGN KEY  (R) : 다른 테이블의 열을 참조하여 존재하는 값만 입력 가능
--CHECK (C) : 설정한 조건식을 만족하는 데이터만 입력 가능

--=================NOT NULL===================

CREATE TABLE TABLE_NOTNULL (LOGIN_ID VARCHAR2(20) NOT NULL, LOGIN_PWD VARCHAR2(20) NOT NULL, TEL VARCHAR2(20) );
DESC TABLE_NOTNULL;

--NULL 삽입 불가
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_01', NULL, '010-1234-5678');

--무결성 충족
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD) VALUES ('TEST_ID_01', '1234');
SELECT * FROM TABLE_NOTNULL;

--NULL로 수정 불가(삭제에도 영향)
UPDATE TABLE_NOTNULL SET LOGIN_PWD = NULL WHERE LOGIN_ID = 'TEST_ID_01';

--제약 조건 살펴보기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

--테이블 생성시 제약 조건 이름 직접 지정 // 실무에서는 제약 조건 이름 지정!!
CREATE TABLE TABLE_NOTNULL2 (LOGIN_ID VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL, LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL, TEL VARCHAR2(20) );
DESC TABLE_NOTNULL2;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

--제약 조건 추가하기 // 대상이 되는 열이 가진 데이터 중 추가하려는 제약 조건에 맞지 않는 데이터 존재
ALTER TABLE TABLE_NOTNULL MODIFY(TEL NOT NULL);

--제약 조건 추가하기
UPDATE TABLE_NOTNULL SET TEL = '010-1234-5678' WHERE LOGIN_ID = 'TEST_ID_01';
SELECT * FROM TABLE_NOTNULL;
ALTER TABLE TABLE_NOTNULL MODIFY TEL NOT NULL;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

--제약 조건에 이름 지정해서 추가하기
ALTER TABLE TABLE_NOTNULL2 MODIFY TEL CONSTRAINT TBL_TEL_NN NOT NULL;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;
DESC TABLE_NOTNULL2;

--제약 조건 이름 변경하기
ALTER TABLE TABLE_NOTNULL2 RENAME CONSTRAINT TBL_TEL_NN TO TBLNN2_TEL_NN;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

--제약 조건 삭제하기
ALTER TABLE TABLE_NOTNULL2 DROP CONSTRAINT TBLNN2_TEL_NN;
DESC TABLE_NOTNULL2;

--================UNIQUE======================

--테이블을 생성하며 제약 조건 지정
CREATE TABLE TABLE_UNIQUE (LOGIN_ID VARCHAR2(20) UNIQUE, LOGIN_PWD VARCHAR2(20) NOT NULL, TEL VARCHAR(20) );
DESC TABLE_UNIQUE;

--제약 조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'TABLE_UNIQUE';

--삽입시 중복 불허
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_01', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_UNIQUE;
INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_01', 'PWD01', '010-1234-5678');

--NOT NULL은 중복 허용
INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_02', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_UNIQUE;

--UNIQUE의 NULL 허용 (NULL간의 비교 불가)
INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL) VALUES (NULL, 'PWD01', '010-2345-6789');
SELECT * FROM TABLE_UNIQUE;

--수정시 중복 불허
UPDATE TABLE_UNIQUE SET LOGIN_ID = 'TEST_ID_01' WHERE LOGIN_ID IS NULL;

--테이블 생성하며 제약 조건 이름 직접 지정
CREATE TABLE TABLE_UNIQUE2 (LOGIN_ID VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNID_UNQ UNIQUE, LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNPW_NN NOT NULL, TEL VARCHAR2(20) );
DESC TABLE_UNIQUE2;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

--제약 조건 추가하기 // 대상이 되는 열이 가진 데이터 중 추가하려는 제약 조건에 맞지 않는 데이터 존재
ALTER TABLE TABLE_UNIQUE MODIFY TEL UNIQUE;

--제약 조건 추가하기
UPDATE TABLE_UNIQUE SET TEL = NULL;
SELECT * FROM TABLE_UNIQUE;
ALTER TABLE TABLE_UNIQUE MODIFY TEL UNIQUE;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

--제약 조건 이름 지정해서 추가하기
ALTER TABLE TABLE_UNIQUE2 MODIFY TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

--제약 조건 이름 변경하기
ALTER TABLE TABLE_UNIQUE2 RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

--제약 조건 삭제
ALTER TABLE TABLE_UNIQUE2 DROP CONSTRAINT TBLUNQ2_TEL_UNQ;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

--==================PRIMARY KEY===================

--UNIQUE의 특성 + NOT NULL의 특성
--테이블에 하나만 지정 가능
--지정된 열은 자동으로 인덱스 생성

--테이블 생성하며 제약 조건 지정하기
CREATE TABLE TABLE_PK ( LOGIN_ID VARCHAR2(20) PRIMARY KEY, LOGIN_PWD VARCHAR2(20) NOT NULL, TEL VARCHAR2(20) );
DESC TABLE_PK;

--제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_PK%';

--자동 생성된 인덱스 확인하기
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME LIKE 'TABLE_PK%';

--테이블 생성하며 제약 조건 이름 지정하기
CREATE TABLE TABLE_PK2 (LOGIN_IN VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY, LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLPK2_LGNPW_NN NOT NULL, TEL VARCHAR2(20) );
DESC TABLE_PK2;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_PK%';
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME LIKE 'TABLE_PK%';

--제약 조건 지정되었는지 확인하기
INSERT INTO TABLE_PK (LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_01', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_PK;
INSERT INTO TABLE_PK (LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_01', 'PW02', '010-2345-6789');
INSERT INTO TABLE_PK (LOGIN_ID, LOGIN_PWD, TEL) VALUES (NULL, 'PW02', '010-2345-6789');
INSERT INTO TABLE_PK (LOGIN_PWD, TEL) VALUES ('PW02', '010-2345-6789');

--ALTER TABLE 명령어 사용시
--생성시점에 확정되는 경우가 대부분
--이미 지정되어 있다면 다른 열에 추가 불가
--중복 값이나 NULL값이 있으면 지정 불가

--CREATE문에서 제약 조건을 지정하는 방식

--inline, column-level
--CREATE TABLE TABLE_NAME(
--  COL1 VARCHAR2(20) CONSTRAINT CONSTRAINT_NAME PRIMARY KEY,
--  COL2 VARCHAR2(20) NOT NULL,
--  COL3 VARCHAR2(20) 
--);

--outline, table-level
--CREATE TABLE TABLE_NAME(
--  COL1 VARCHAR2(20),
--  COL2 VARCHAR2(20),
--  COL3 VARCHAR2(20)
--  PRIMARY KEY (COL1).
--  CONSTRAINT CONSTRAINT_NAME UNIQUE (COL2)
--);

--=============FOREIGN KEY===================

--EMP TABLE & DEPT TABLE constraint condition
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_OWNER, R_CONSTRAINT_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME IN('EMP', 'DEPT');
--외래키가 참조하는 열에 존재하지 않는 데이터 입력하기
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (9999, '홍길동', 'CLERK', '7788', TO_DATE ('2017/04/30', 'YYYY/MM/DD'), 1200, NULL, 50 );

--inline, column-level
--CREATE TABLE 테이블 이름 (…(다른 열 정의), 열 자료형 CONSTRAINT 제약조건이름 REFERENCES 참조테이블(참조할 열) );
--outline, table-level
--CREATE TABLE 테이블 이름 (…(다른 열 정의), CONSTRAINT 제약조건이름 FOREIGN KEY 열 REFERENCES 참조테이블 (참조할 열) );

--참조 대상이 될 테이블 생성하기
CREATE TABLE DEPT_FK (DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY, DNAME VARCHAR2(14), LOC VARCHAR2(13) );
DESC DEPT_FK;
--외래키 제약 조건을 정의한 테이블 생성하기
CREATE TABLE EMP_FK (EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY, ENAME VARCHAR2(10), JOB VARCHAR2(9), MGR NUMBER(4), HIREDATE DATE, SAL NUMBER(7, 2), COMM NUMBER(7, 2), DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK (DEPTNO) );
DESC EMP_FK;

--참조 주체가 참조 대상의 열에 존재하지 않는 값을 사용하는 것은 불가능하다.
--외래키는 다른 테이블의 기본키여야 한다. 참조 대상 테이블의 기본키, 즉 부모키가 없다면 오류 발생
INSERT INTO EMP_FK VALUES(9999, ‘TEST_NMAME’, ‘TEST_JOB’, NULL, TO_DATE(’2001/01/01’, ‘YYYY/MM/DD’), 3000, NULL, 10);

--선...참조 대상 테이블의 기본키에 데이터 삽입
INSERT INTO DEPT_FK VALUES (10, ‘TEST_DNAME’, ‘TEST_LOC’);
SELECT * FROM DEPT_FK;
--후...참조 행위의 주체 테이블의 외래키에 데이터 삽입
INSERT INTO EMP_FK VALUES(9999, ‘TEST_NMAME’, NULL, TO_DATE(’2001/01/01’, ‘YYYY/MM/DD’), 3000, NULL, 10);
SELECT * FROM EMP_FK;

--삭제하려는 값을 참조하는 데이터가 존재하면 오류가 발생한다. 
DELETE FROM DEPT_FK WHERE DEPTNO = 10;

--1. 현재 삭제하려는  열 값을 참조하는 데이터를 먼저 삭제한다.
--2. 현재 삭제하려는 열 값을 참조하는 데이터를 수정한다. (해당 열의 다른 값 또는 NULL로 변경한다.)
--3. 현재 삭제하려는 열을 참조하는 자식 테이블의 외래키 제약 조건을 해제한다. 
--위 방법은 삭제할 데이터를 참조하는 데이터의 수정 또는 삭제 작업을 선행해야 함.
--외래키 제약 조건을 해제할 수 없는 경우도 종종 있음

--(제약 조건을 처음 지정할 때 추가 옵션을 지정하는 방법)
--열 데이터를 삭제할 때 이 데이터를 참조하고 있는 데이터도 함께 삭제
--CONSTRAINT 제약조건이름 REFERENCES 참조테이블(참조할 열) IN DELETE CASCADE
--열 데이터를 삭제할 때 이 데이터를 참조하는 데이터를 NULL로 수정
--CONSTRAINT 제약조건이름 REFERENCES 참조테이블(참조할 열) ON DELETE SET NULL

--외래키 제약 조건도 테이블을 설계하는 시점에 결정나는 경우가 많다.

--======================CHECK=========================

--활용: 열에 저장할 수 있는 값의 범위 또는 패턴 정의할 때 사용